<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luckyfbb.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="根据想学习 React 源码的初衷，但是又不了解 React 的大体工作流程，在某博主的指引下找到了一篇mini 教程，由于是英文文档所以在此记录从头开始写 React 的过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="build-your-own-React">
<meta property="og:url" content="https://luckyfbb.github.io/2020/11/14/build-your-own-React/index.html">
<meta property="og:site_name" content="LuckyFBB&#39;s Blog">
<meta property="og:description" content="根据想学习 React 源码的初衷，但是又不了解 React 的大体工作流程，在某博主的指引下找到了一篇mini 教程，由于是英文文档所以在此记录从头开始写 React 的过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luckyfbb.github.io/image/buildReact/fiber.png">
<meta property="og:image" content="https://luckyfbb.github.io/image/buildReact/fiber_goal.png">
<meta property="article:published_time" content="2020-11-14T03:18:43.000Z">
<meta property="article:modified_time" content="2021-03-12T09:20:22.000Z">
<meta property="article:author" content="LuckyFBB">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luckyfbb.github.io/image/buildReact/fiber.png">

<link rel="canonical" href="https://luckyfbb.github.io/2020/11/14/build-your-own-React/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>build-your-own-React | LuckyFBB's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LuckyFBB's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">路漫漫其修远兮</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luckyfbb.github.io/2020/11/14/build-your-own-React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="LuckyFBB">
      <meta itemprop="description" content="时间久了，问题也多了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckyFBB's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          build-your-own-React
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-14 11:18:43" itemprop="dateCreated datePublished" datetime="2020-11-14T11:18:43+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 17:20:22" itemprop="dateModified" datetime="2021-03-12T17:20:22+08:00">2021-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>根据想学习 React 源码的初衷，但是又不了解 React 的大体工作流程，在某博主的指引下找到了一篇<a target="_blank" rel="noopener" href="https://pomb.us/build-your-own-react/">mini 教程</a>，由于是英文文档所以在此记录从头开始写 React 的过程。</p>
<span id="more"></span>
<p>在我们重写 React 的过程中需要依次做如下的事情:</p>
<ol>
<li>The createElement Function</li>
<li>The render Function</li>
<li>Concurrent Mode</li>
<li>Fibers</li>
<li>Render and Commit Phases</li>
<li>Reconciliation</li>
<li>Function Components</li>
<li>Hooks</li>
</ol>
<h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p>在开始之前，首先需要回顾一下基础概念。如果在此之前你已经了解 React/JSX/Dom Elements 工作的方式，可以跳过这个步骤。<br>我们将使用仅有三行的 React 程序。第一行是定义 React 元素。第二行是从 DOM 中获取一个节点。第三行是渲染 React 元素到容器中。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">ReactDOM.render(element, container);</span><br></pre></td></tr></table></figure>
<p>我们将用原生 JS 替换掉 React 代码。<br>第一行代码使用 JSX 定义了一个元素，他甚至不是有效的 JS，因此要用原生的 JS 取代它。首先我们用有效的 JS 替换它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">&quot;h1&quot;</span>, &#123; <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span> &#125;, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>JSX 通过 Babel 这种工具被编译为 JS。这种编译方式很简单，使用对 createElement 的调用来替换 tag 内的代码，并将 tag 名称，props 和 children 作为参数传递。<br>React.CreateElement 通过他的参数创建一个对象。除了一些验证之外，这就是全部了。因此我们可以将函数调用替换为它的输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>element 是什么，一个有 type 和 props 两个属性的对象。(其实还有<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111">别的属性</a>，但是我们只在意这两个。)<br>type 是一个字符串，用于指定我们需要创建的 DOM 节点类型，它是创建 HTML 元素时传递给 document.createElement 的 tagName。它也可以是一个函数，我们留到第七步。<br>props 是另一个对象，他具有 JSX 属性的所有 key-value 值，他还有一个特殊的属性：children。<br>children 在这个例子中是一个字符串，但是通常是一个包含更多元素的数组，这就是为什么元素大多是树的原因。</p>
<p>我们需要替换另一部分的 React 代码是 ReactDOM.render 的调用，render 是 React 改变 DOM 的地方，所以让我们自己进行更新。<br>首先，我们使用元素类型(本例中的 h1)创建一个 node。然后我们将所有元素的 props 分配给该节点，这里是 title 字段。为了避免混淆，我们使用 element 来指代 React 元素，并使用 node 来指代 DOM 元素。<br>我们为 children 创建节点，我们只有一个字符串作为子代，因此我们创建一个文本节点。<br>使用 textNode 而不是设置 innerText 将允许我们以后用相同的方式对待所有的元素。另外请注意我们已经像设置 h1 标题一样设置 nodeValue，就像字符串中带有 props 一样：{nodeValue:”hello”}</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type);</span><br><span class="line">node[<span class="string">&quot;title&quot;</span>] = element.props.title;</span><br><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>);</span><br><span class="line">text[<span class="string">&quot;nodeValue&quot;</span>] = element.props.children;</span><br></pre></td></tr></table></figure>
<p>最后我们把 textNode 添加到 h1 上并将 h1 添加到容器上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.appendChild(text);</span><br><span class="line">container.appendChild(node);</span><br></pre></td></tr></table></figure>
<p>现在我们有和以前相同的应用程序，但是没有使用 React。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">&quot;title&quot;</span>] = element.props.title</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">text[<span class="string">&quot;nodeValue&quot;</span>] = element.props.children</span><br><span class="line">​</span><br><span class="line">node.appendChild(text)</span><br><span class="line">container.appendChild(node)</span><br></pre></td></tr></table></figure>
<h3 id="The-createElement-Function"><a href="#The-createElement-Function" class="headerlink" title="The createElement Function"></a>The createElement Function</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">b</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">ReactDOM.render(element, container);</span><br></pre></td></tr></table></figure>
<p>我们从另一个应用程序开始。这次，我们将用自己的 React 版本替换 React 代码。<br>我们编写自己的 createElement 开始。<br>让我们将 JSX 转换为 JS，以便可以看到 createElement 调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bar&quot;</span>),</span><br><span class="line">  React.createElement(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>正如我们在前一步看到的，一个 element 是一个剧有 type 和 props 的对象。函数需要做的唯一一件事就是创建那样的对象。<br>我们对道具使用扩展运算符，对 children 使用 rest 参数语法，这样 children 将始终是数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">createElement(<span class="string">&quot;div&quot;</span>) returns:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [] &#125;</span><br><span class="line">&#125;</span><br><span class="line">createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, a) returns:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [a] &#125;</span><br><span class="line">&#125;</span><br><span class="line">createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, a, b) returns:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [a, b] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>children 数组可能包含原始值(数字和字符串)。因此，我们会将不是对象的所有内容包含在其自己的元素中，并为其创建特殊类型:TEXT_ELEMENT。<br>当没有子节点时，React 没有包装原始值或者创建空数组。但是我们这样做得目的是它简化我们的代码，对于我们的库来说，更喜欢简单的代码而不是高性能的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.map(<span class="function">(<span class="params">child</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在仍然使用的 React.createElement。为了替换他，为我们的库取一个名字。我们需要去一个听起来像 react 的名字但是暗示它的教学目的。我们取名字叫 Didact。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  Didact.createElement(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bar&quot;</span>),</span><br><span class="line">  Didact.createElement(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们仍然想使用 JSX，如何能告诉 Babel 使用 Didact 的 createElement 而不是 React 的。<br>我们需要有一个注释，当 babel 转译 JSX 时，它将使用我们定义的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">b</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="The-render-Function"><a href="#The-render-Function" class="headerlink" title="The render Function"></a>The render Function</h3><p>我们需要编写我们的 ReactDOM.render 函数版本。<br>目前，我们只关心向 DOM 添加内容，稍后我们处理更新和删除。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO create dom nodes</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">b</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">Didact.render(element, container)</span><br></pre></td></tr></table></figure>
<p>我们开始于用 element 的类型创建 DOM，然后把它添加到容器中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(element.type);</span><br><span class="line">  <span class="comment">//递归每一个子节点。</span></span><br><span class="line">  element.props.children.map(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    render(child, dom);</span><br><span class="line">  &#125;);</span><br><span class="line">  container.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的我们需要处理文本节点，如果是 TYPE_ELEMENT，我们创建一个文本节点而不是一个常规节点。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//const dom = document.createElement(element.type);</span></span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type === <span class="string">&quot;TYPE_ELEMENT&quot;</span></span><br><span class="line">      ? createTextElement(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : createElement(element.type);</span><br><span class="line">  element.props.children.map(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    render(child, dom);</span><br><span class="line">  &#125;);</span><br><span class="line">  container.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要做的最后一件事是合并 element 的 props 到这个节点中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPorperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">  .filter(isPorperty)</span><br><span class="line">  .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    dom[name] = element.props[name];</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经有一个能够渲染 JSX 到 DOM 的库了。<br>在<a target="_blank" rel="noopener" href="https://codesandbox.io/s/didact-2-k6rbj">codesandbox</a>上进行尝试。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.map(<span class="function">(<span class="params">child</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(element.type);</span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.props[name];</span><br><span class="line">    &#125;);</span><br><span class="line">  element.props.children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> render(child, dom));</span><br><span class="line">  container.appendChild(dom);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>FBB<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">Didact.render(element, container);</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h3><p>在我们添加更多的代码之前，我们需要进行重构。</p>
<p>上文中的 render 递归调用存在问题。<br>一旦我们开始渲染之后，等到整个 element 树渲染完成，我们才会停下来。如果这个 element 树太大，它将阻塞主进程太长的时间。如果浏览器需要做一些优先级更高的事，例如处理用户输入或者保持平滑的动态效果，他们都必须等待渲染完成。<br>所以我们把整个过程分成几个单元，在完成每个单元之后，如果需要执行其他的操作，我们将让浏览器中断渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitWork = performUnitOfWork(nextUnitWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line">requestIdleCallback(workLoop);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">nextUnitWork</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 requestIdleCallback 进行循环。你可以把 requestIdleCallback 当作一个 setTimeout，浏览器将在主线程空闲时运行回调，而不是告诉它何时运行。<br>React 不在使用 requestIdleCallback。现在它使用调度程序包。但是对于此用例，他在概念上是相同的。<br>requestIdleCallback 为我们提供一个截至日期参数。我们可以使用它来检查浏览器需要再次控制之前有多少时间。<br>要开始使用循环，我们需要设置第一个工作单元，然后编写一个 performUnitOfWork 函数，该函数不仅执行工作，还返回下个工作单元。</p>
<h3 id="Fibers"><a href="#Fibers" class="headerlink" title="Fibers"></a>Fibers</h3><p>为了组织工作单元，我们需要一个数据结构：fiber tree。<br>我们为每一个 element 分配一个 fiber，并且每个 fiber 将成为一个工作单元。<br>让我举个例子。</p>
<div style="margin: auto"><img src="/image/buildReact/fiber.png" alt="image.png"></div>

<p>实际上我们想要渲染一个 element 树像下面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Didact.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在这个渲染中，我们创建根 fiber 并且把它作为 nextUnitWork，其他剩下的工作将在 performUnitOfWork 中进行，对于每个 fiber 我们将做三件事情：</p>
<ol>
<li>添加 element 到 DOM 中</li>
<li>为 element 的子节点添加 fiber</li>
<li>选择下一个工作单元</li>
</ol>
<p>该数据结构的目标之一是便利的查找一个工作单元。这就是为什么每个 fiber 都有一个链接到他的第一个子节点，下一个兄弟姐妹和父节点。</p>
<div style="margin: auto"><img src="/image/buildReact/fiber_goal.png" alt="image.png"></div>

<p>当我们完成对 fiber 的工作时，如果他有子节点，子节点 fiber 则会成为下一个工作单元。<br>从我们例子中来看，当我们完成 div fiber 的工作，下一个工作单元将是 h1 fiber。如果当前 fiber 没有孩子，我们将使用 sibling 作为下一个工作单元。例如，p fiber 没有孩子所以我们在完成 p 之后转向 a fiber。<br>如果这个 fiber 没有孩子或者兄弟节点我们将处理他父节点的兄弟节点，例如 a 和 h2 fibers。<br>如果父节点没有兄弟节点，我们将不断向上查找父节点，直到查找到有兄弟节点的父节点或者是到达根 fiber。如果到达根 fiber，意味着我们完成了此渲染工作。<br>让我们开始写代码。</p>
<p>第一步，我们移除 render 函数中的代码。<br>我们将创建 DOM 节点的部分保留在其自身的功能中，稍后将使用它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDOM</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type);</span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(fiber.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = fiber.props[name];</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 render 函数中，我们将 nextUnitWork 设置为 fiber 树的根。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>当浏览器准备好了，我们将调用循环并且开始在根上工作。</p>
<ol>
<li>首先我们创建一个新的节点并把它加入到 dom 中。</li>
<li>我们在 fiber.dom 属性中跟踪 DOM 节点。为每一个子节点创建一个 fiber。我们将其添加到 fiber tree 中，将其设置为子代还是同级取决于它是否是第一个子代。</li>
<li>最后我们查找下一个工作单元。我们首先尝试与子代，然后与兄弟然后是父节点的兄弟，以此类推。</li>
</ol>
<p>这就完成了我们的 performUnitOfWork。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add dom node</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDOM(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.type,</span><br><span class="line">      <span class="attr">props</span>: element.props,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> fiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Render-and-Commit-Phases"><a href="#Render-and-Commit-Phases" class="headerlink" title="Render and Commit Phases"></a>Render and Commit Phases</h3><p>我们这里还有另一个问题。<br>每次处理元素时，我们都会向 DOM 添加一个新节点。在完成渲染整个树之前，浏览器可能会中断我们的工作。在这种情况下，用户将看到不完整的 UI，我们不想那样。<br>因此我们从此处删除更改 DOM 的部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add dom node</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDOM(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//删除部分</span></span><br><span class="line">  <span class="comment">/* if (fiber.parent) &#123;</span></span><br><span class="line"><span class="comment">    fiber.parent.dom.appendChild(fiber.dom);</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，我们引用 fiber tree 的根。我们称之为 work in progress root(wipRoot)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>一旦我们完成了所有的工作(我们知道完成了是因为没有下一个工作单元了)，我们提交整个 fiber tree 到 DOM 中。<br>我们在 commitRoot 函数中做到这一点，在这里我们将多有节点递归添加到 DOM 中。</p>
<h3 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h3><p>到目前为止，我们仅向 DOM 中添加内容，但是更新或者删除节点又怎么做呢？<br>那是我们现在要做的，我们需要将在 render 函数上收到的元素与我们提交给 DOM 的最后一棵 fiber tree 做比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  domParent.appendChild(fiber.dom)</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，在完成提交之后，我们需要储存”我们提交给 DOM 的最后一个 fiber tree”的引用。我们称它为 currentRoot。<br>我们也添加 alternate 属性到每一个 fiber。这个属性是我们在上一个提交阶段 fiber 的链接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//TODO set next unit of work</span></span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;;</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add nodes to dom</span></span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>现在我们从 performUnitOfWork 中提取代码，该代码将新的 fiber 来创建到新的 reconcileChildren 函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add dom node</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  reconcileChildren(fiber, elements);</span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.type,</span><br><span class="line">      <span class="attr">props</span>: element.props,</span><br><span class="line">      <span class="attr">parent</span>: wipFiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      wipFiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将旧 fiber 和新的 element 进行比较。<br>我们同时遍历旧 fiber 的子级(wipFiber.alternate)和要比较的元素数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// TODO campare oldFiber to element</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们忽略了同时迭代数组和链接列表所需的所有样板，那么这次循环剩下的就是 oldFiber 和 element。 element 是我们要渲染到 DOM 的东西，而 oldFiber 是我们上次渲染的东西。<br>我们需要对它进行比较，查看是否需要对 DOM 进行修改。<br>了比较它们，我们使用这种方法：</p>
<ul>
<li>如果旧 fiber 和新 element 具有相同的类型，我们可以保留 DOM 节点并仅使用新 props 进行更新</li>
<li>如果类型不同并且有一个新元素，则意味着我们需要创建一个新的 DOM 节点</li>
<li>并且如果类型是不同的并且有一个旧 fiber，我们需要删除旧的节点</li>
</ul>
<p>在这里，React 也使用 keys，这样可以实现更好的比较。 例如，它检测子元素何时更改元素数组中的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// TODO campare oldFiber to element</span></span><br><span class="line">    <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; oldFiber.type === element.type;</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      <span class="comment">//TODO Update Node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// TODO add this node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// TODO delete the oldFiber&#x27;s node</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当旧 fiber 和 element 有一样的 type 时，我们创建一个新 fiber 保存旧 fiber 的 DOM 节点和 element 的 props 属性。<br>我们也添加新属性 effectTag 到 fiber 中，我们将在提交阶段使用这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">  <span class="comment">//TODO Update Node</span></span><br><span class="line">  newFiber = &#123;</span><br><span class="line">    <span class="attr">type</span>: oldFiber.type,</span><br><span class="line">    <span class="attr">props</span>: element.props,</span><br><span class="line">    <span class="attr">dom</span>: oldFiber.dom,</span><br><span class="line">    <span class="attr">parent</span>: wipFiber,</span><br><span class="line">    <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">    <span class="attr">effectTag</span>: <span class="string">&quot;Update&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有 element 且 type 不一样，我们用 PLACEMENT 来标记新 fiber。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">  <span class="comment">// TODO add this node</span></span><br><span class="line">  newFiber = &#123;</span><br><span class="line">    <span class="attr">type</span>: element.type,</span><br><span class="line">    <span class="attr">props</span>: element.props,</span><br><span class="line">    <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">parent</span>: wipFiber,</span><br><span class="line">    <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有旧 fiber 且 type 不一样，我们不需要新 fiber，所以我们添加 DELETION 来标记旧 fiber。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">  <span class="comment">// TODO delete the oldFiber&#x27;s node</span></span><br><span class="line">  oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">  deletions.push(oldFiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们将 fiber tree 提交给 DOM 时，我们是从 wipRoot 开始的，它没有旧 fiber。</p>
<p>我们需要一个数组保存我们需要删除节点的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//TODO set next unit of work</span></span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//other code</span></span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>然后，我们将更改提交到 DOM 时，我们也是用数组中的 fiber。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add nodes to dom</span></span><br><span class="line">  deletions.forEach(commitWork);</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们来处理新 effectTags 通过修改 commitWork。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  domParent.appendChild(fiber.dom);</span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 fiber 有’PLACEMENT’的标签，我们会像之前一样把 DOM 节点添加到父级节点中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是’DELETION’，我们相反的处理，删除这个节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是’UPDATE’，我们更新修改之后的 props 到已存在的 DOM 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    updateDom(fiber.dom, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来编写 updateDom 函数。<br>我们比较来自旧 fiber 和新 fiber 的 props，移除掉不需要的 props 和设置新的与更改过的 props。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Romove obl properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件监听类的 prop 是我们需要更新的 prop，如果属性名是以’on’开头我们会特殊处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function">(<span class="params">key</span>) =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key);</span><br></pre></td></tr></table></figure>
<p>如果事件处理改变我们将他从节点删除，然后我们会添加新的事件处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Romove old or changed event listneners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="comment">//Romove old properties</span></span><br><span class="line">  <span class="comment">//Set new or changed properties</span></span><br><span class="line">  <span class="comment">//Add event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 createDom 中使用 updateDom 函数，做出如下修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDOM</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type);</span><br><span class="line">  updateDom(dom, &#123;&#125;, fiber.props);</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此，我们已经有了新版本的全部代码。】<br>在<a target="_blank" rel="noopener" href="https://codesandbox.io/s/didact-6-96533">codesandbox</a>尝试带有 reconciliation 的版本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.map(<span class="function">(<span class="params">child</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDOM</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type);</span><br><span class="line">  updateDom(dom, &#123;&#125;, fiber.props);</span><br><span class="line">  <span class="keyword">return</span> dom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isEvent = <span class="function">(<span class="params">key</span>) =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function">(<span class="params">key</span>) =&gt;</span> key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key);</span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> prev[key] !== next[key];</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> next);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//Romove old or changed event listneners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !(key <span class="keyword">in</span> nextProps) || isNew(prevProps, nextProps)(key))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="comment">//Romove old properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name];</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="comment">//Add event listeners</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isEvent)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">      dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//TODO set next unit of work</span></span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">  &#125;;</span><br><span class="line">  deletions = [];</span><br><span class="line">  nextUnitOfWork = wipRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add nodes to dom</span></span><br><span class="line">  deletions.forEach(commitWork);</span><br><span class="line">  commitWork(wipRoot.child);</span><br><span class="line">  currentRoot = wipRoot;</span><br><span class="line">  wipRoot = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom;</span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    domParent.appendChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp; fiber.dom !== <span class="literal">null</span>) &#123;</span><br><span class="line">    updateDom(fiber.dom, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom);</span><br><span class="line">  &#125;</span><br><span class="line">  commitWork(fiber.child);</span><br><span class="line">  commitWork(fiber.sibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> deletions = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    commitRoot();</span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(workLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add dom node</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDOM(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  <span class="keyword">const</span> elements = fiber.props.children;</span><br><span class="line">  reconcileChildren(fiber, elements);</span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nextFiber = fiber;</span><br><span class="line">  <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fiber.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> fiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    nextFiber = nextFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child;</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index];</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// TODO campare oldFiber to element</span></span><br><span class="line">    <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; oldFiber.type === element.type;</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      <span class="comment">//TODO Update Node</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: oldFiber.type,</span><br><span class="line">        <span class="attr">props</span>: element.props,</span><br><span class="line">        <span class="attr">dom</span>: oldFiber.dom,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&quot;Update&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// TODO add this node</span></span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: element.type,</span><br><span class="line">        <span class="attr">props</span>: element.props,</span><br><span class="line">        <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      <span class="comment">// TODO delete the oldFiber&#x27;s node</span></span><br><span class="line">      oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span>;</span><br><span class="line">      deletions.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      wipFiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    prevSibling = newFiber;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Didact = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> updateValue = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  rerender(e.target.value);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rerender = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">onInput</span>=<span class="string">&#123;updateValue&#125;</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello &#123;value&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  Didact.render(element, container);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rerender(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Function-Components"><a href="#Function-Components" class="headerlink" title="Function Components"></a>Function Components</h3><p>下面我们需要做的事情是支持函数组件。</p>
<p>第一步我们修改这个例子。我们使用一个简单的函数组件，它返回 h1 元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hi &quot;</span>, props.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(App, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>函数组件有两个方面的不同：</p>
<ul>
<li>来自函数组件的 fiber 没有 DOM 节点</li>
<li>child 是来自运行函数，而不是直接从 props 中获取的</li>
</ul>
<p>我们会检查 fiber 的 type 属性是否为函数，这决定于我们使用不同的更新函数。<br>在 updateHostComponent 中，和之前的处理一样。<br>在 updateFunctionComponent 中，我们获取 children。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isFunctionComponent = fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span>;</span><br><span class="line">  <span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">    updateFunctionComponent(fiber);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add dom node</span></span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDOM(fiber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  reconcileChildren(fiber, fiber.props.children);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)];</span><br><span class="line">  reconcileChildren(fiber, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的例子中，fiber.type 是 App 函数，当我们运行它时，它会返回 h1 元素。<br>一旦我们获取到 children，reconciliation 这一步骤会一样的执行，我们不需要改任何的东西。</p>
<p>我们还需要改 commitWork 函数。<br>现在我们有了不含 DOM 节点的 fiber，我们需要改两个地方。<br>首先需要找到 DOM 节点的父级，我们沿着 fiber tree 一直向上移动，直到找到带有 DOM 节点的 fiber。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  .<span class="comment">//...</span></span><br><span class="line">  <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">  <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = domParentFiber.dom;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当移除节点时，需要继续执行直到我们找到一个带有 child 的 DOM 节点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">    commitDeletion(fiber, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.dom) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    commitDeletion(fiber.child, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>最后一步。现在我们有函数组件了，让我们添加 state。</p>
<p>我们将示例改为经典计数器组件，每次单击它，状态都会增加 1。我们现在使用 Didact.useState 获取和更新计数器值。</p>
<p>在这里，我们从示例中调用 Counter 函数。在该函数内部，我们称为 useState。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState((c) =&gt; c + 1)&#125;&gt;Count: &#123;state&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们需要在调用函数组件之前初始化一些全局变量，以便我们在 useState 函数中使用它们。<br>首先我们设置 work in progress fiber。<br>我们在 fiber 中添加一个 hook 数组，为了支持在同一组件中多次调用 useState 函数。我们追踪当前 hook 的索引。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> wipFiber = fiber;</span><br><span class="line">  hookIndex = <span class="number">0</span>;</span><br><span class="line">  wipFiber.hooks = [];</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)];</span><br><span class="line">  reconcileChildren(fiber, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数组件调用 useState 函数时，我们检查是否有一个旧的 hook。我们检查 fiber 的 alternate 是否使用 hook。<br>如果有旧的 hook，我们将旧的 hook 复制到新的 hook 中；如果没有我们初始化 state。<br>然后我们添加新的 hook 到 fiber，hookIndex 加一，然后返回 state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldhook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex];</span><br><span class="line">  <span class="keyword">const</span> hook = &#123; <span class="attr">state</span>: oldHook ? oldHook.state : initial &#125;;</span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>useState 也要返回一个更新 state 的函数，因此需要定义一个可以接受 action 的函数(例如在 Counter 例子中，action 是一个自增函数)。<br>我们把 action 放到一个队列中并添加到 hook 上。<br>然后我们做和 render 函数相同的事情，设置一个新的 work in progress root 作为下一个工作单元，以便工作循环能够开启一个新的渲染阶段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//oldhook</span></span><br><span class="line">  <span class="keyword">const</span> hook = &#123; <span class="attr">state</span>: oldHook ? oldHook.state : initial, <span class="attr">queue</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action);</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      <span class="attr">dom</span>: dom.currentRoot.dom,</span><br><span class="line">      <span class="attr">props</span>: currentRoot.props,</span><br><span class="line">      <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">    &#125;;</span><br><span class="line">    nextUnitOfWork = wipRoot;</span><br><span class="line">    deletions = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们还没有执行 action。<br>我们将在下一次渲染组件的时候执行它，我们从旧的 hook 中拿到所有 action，并且逐一将他们应用到新的 hook state，以便我们返回时，已经是更新状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//oldhook</span></span><br><span class="line">  <span class="keyword">const</span> hook = &#123; <span class="attr">state</span>: oldHook ? oldHook.state : initial, <span class="attr">queue</span>: [] &#125;;</span><br><span class="line">  <span class="keyword">const</span> actions = oldHook ? oldHook.queue : [];</span><br><span class="line">  actions.forEach(<span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    hook.state = action(hook.state);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action);</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      <span class="attr">dom</span>: dom.currentRoot.dom,</span><br><span class="line">      <span class="attr">props</span>: currentRoot.props,</span><br><span class="line">      <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">    &#125;;</span><br><span class="line">    nextUnitOfWork = wipRoot;</span><br><span class="line">    deletions = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  wipFiber.hooks.push(hook);</span><br><span class="line">  hookIndex++;</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是全部了，可以尝试部署属于自己的 react 了。<br>可以在<a target="_blank" rel="noopener" href="https://codesandbox.io/s/didact-8-21ost">codesandbox</a> 和 <a target="_blank" rel="noopener" href="https://github.com/pomber/didact">github</a> 上运行。</p>
<h3 id="Epilogue"><a href="#Epilogue" class="headerlink" title="Epilogue"></a>Epilogue</h3><p>除了帮助您了解 React 的工作原理外，本文的目的之一是使您更轻松地深入 React 代码库。 这就是为什么我们几乎在所有地方都使用相同的变量和函数名称的原因。</p>
<p>例如，如果您在真正的 React 应用程序的功能组件之一中添加断点，则调用堆栈应显示：</p>
<ul>
<li>workLoop</li>
<li>performUnitOfWork</li>
<li>updateFunctionComponent</li>
</ul>
<p>我们没有包括很多 React 功能和优化。 例如，以下是 React 可以做的一些不同的事情：</p>
<ul>
<li>在 Didact 中，我们在渲染阶段遍历整棵树。 相反，React 遵循一些提示和试探法，以跳过没有任何更改的整个子树。</li>
<li>我们还在提交阶段遍历整棵树。 React 仅保留有影响的 fibers 并仅访问那些 fibers 的链表。</li>
<li>每次我们建立一个新的进行中的工作树时，我们都会为每根 fiber 创建新的对象。 React 回收了先前树中的 fiber。</li>
<li>当 Didact 在渲染阶段收到新的更新时，它将丢弃进行中的工作树，然后从根开始重新进行。 React 使用过期时间戳标记每个更新，并使用它来决定哪个更新具有更高的优先级。</li>
<li>更多…</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/React/" rel="tag"># React</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/24/%E6%A0%88-%E9%98%9F%E5%88%97%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/" rel="prev" title="栈/队列的解题思路">
      <i class="fa fa-chevron-left"></i> 栈/队列的解题思路
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="next" title="十大排序算法">
      十大排序算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Review"><span class="nav-number">1.</span> <span class="nav-text">Review</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-createElement-Function"><span class="nav-number">2.</span> <span class="nav-text">The createElement Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-render-Function"><span class="nav-number">3.</span> <span class="nav-text">The render Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concurrent-Mode"><span class="nav-number">4.</span> <span class="nav-text">Concurrent Mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fibers"><span class="nav-number">5.</span> <span class="nav-text">Fibers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Render-and-Commit-Phases"><span class="nav-number">6.</span> <span class="nav-text">Render and Commit Phases</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reconciliation"><span class="nav-number">7.</span> <span class="nav-text">Reconciliation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-Components"><span class="nav-number">8.</span> <span class="nav-text">Function Components</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hooks"><span class="nav-number">9.</span> <span class="nav-text">Hooks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Epilogue"><span class="nav-number">10.</span> <span class="nav-text">Epilogue</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LuckyFBB"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">LuckyFBB</p>
  <div class="site-description" itemprop="description">时间久了，问题也多了</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LuckyFBB</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <span class="post-count">| 博客共93k字</span>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
